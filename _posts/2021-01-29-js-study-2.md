---
title:  "자바스크립트 책 요약 - 2"
excerpt: "자바스크립트 책에 내용을 가볍게 정리해보았다. 2"

categories:
  - Study
tags:
  - javascript

---

# 자바스크립트 공부 - 2 (7장부터 12장까지)

**출처**
**'모던자바스크립트 Deep DIve - 자바스크립트의 기본 개념과 동작원리'**를 읽고

## 7. 연산자

### 1. 산술 연산자

	1. 이항 ->  +, -, *, /, %
 	2. 단항 -> ++, --  실제 값을 바꾼다. |  +, -  실제 값을 바꾸지는 않는다.

### 2. 할당 연산자

1. 종류 : = , += , -=, /=, *=, %=

### 3. 비교 연산자

1. 종류: ==, ===, != , !==, isNaN, Object.is( 음,양의 0과 NaN 간 비교를 위해서 ES6에서 추가)

### 4. 대소 비교 연산자

### 5. 삼항 조건 연산자

### 6. 논리 연산자

### 7. 그 밖의 연산자

1. typeof - 데이터 타입을 문자열로 반환 / 선언하지 않은 식별자는 undefined 반환(ReferenceError가 아니다!!)
2. 지수 연산자(ES7) - **    ex) 2 ** 0 = 2^0 = 1  / 음수는 괄호로 감싸주자!
3. delete, new 등등 나중에 뒷장에서 설명

---

## 8. 제어문

1. 블록문 
   자체 종결성을 가지기 때문에 세미콜론을 붙이지 않는다.
2. 조건문
if...else,  switch / 총 2개가 있다.
3. 반복문
   for문, while문, do...while문 / 총 3개가 있다.
4. break / continue

## 9. 타입 변환과 단축평가

1. 타입변환?
   크게 명시적 타입 변환(타입캐스팅)과 암묵적 타입변환(타입 강제 변환)이 있다.

2. 자바스크립트는 암묵적으로 되는 경우가 대부분이다. 단순하게 요약해보면

   1. 산술연산자 중 + 는 문자열 > 숫자
   2. 나머지 문자열  < 숫자, 단 계산 불가시 NaN
   3. 비교 연산자 문자열 < 숫자
   4. '', [], null, false 는 0, true는 1, 객체와 채워진 배열, undefined는 NaN
   5. false로 취급되는 애들: false, undefined, null, 0, -0, NaN, ''

3. 명시적은 보통 String, Object.prototype.toString,  + '', Number, parseInt, parseFloat, +, *, Boolean, !!

4. 단축평가?
   단순하게 논리 연산에서 앞에서 결론이 나면 뒤에것을 스킵하는것
   ex) true || anything 이면 anything 확인 필요 없음

5. 옵셔널 체이닝 연산자
   ES11 도입
   기존의 null, undefined를 확인하고 프로퍼티를 참조하던것을 간편화!!

   ```javascript
   var elem = null;
   var value = elem?.value;
   console.log(value); // undefined
   ```

6. null 병합 연산자
   ES11 도입
   좌항이 null / undefined 이면 우항을 리턴, 아니면 좌항을 리턴한다.

   ```javascript
   var foo = null ? 'test';
   console.log(foo); // test
   ```

---

## 10. 객체 리터럴

1. 객체는 변경 가능한 값

2. 0가지 이상의 프로퍼티로 구성된 집합

3. 프로퍼티란? 키와 값으로 구성

   1. 함수도 프로퍼티로 사용 가능. 이 때는 메서드라고 부른다

   2. 식별자 네이밍 규칙을 준수해야한다.

      ```javascript
      var person = {
      	firstName: 'test',
      	'last-name': 'test'
      };
      console.log(person); // {firstName: "test", last-name: "test"}
      ```

   3. 뒤에 선언한 프로퍼티가 덮어쓴다.

4. 메서드 - 객체에 묶여있는 함수

5. 프로퍼티 접근

   1. 마침표 표기법 
   2. 대괄호 표기법
   3. 존재하지 않는 프로퍼티 - undefined

6. 동적으로 값 생성, 갱신이 가능하다

7. delete로 삭제도 가능하다

8. ES6 이후로 축약표현이 가능하다 {x: x, y:y} => {x,y}

9. ES5: 프로퍼티 외부에서 계산식으로 생성 가능
   ES6: 프로퍼티 내부에서도 계산식으로 생성 가능

10. ES6: 메서드도 축약표현이 가능 (단, 동작 과정이 다르다고 한다.)

---

## 11. 원시 값과 객체의 비교

|       구분       |             원시 타입              |                객체 타입                |
| :--------------: | :--------------------------------: | :-------------------------------------: |
|       변경       |                불가                |                  가능                   |
|       변수       |              실제 값               |                 참조 값                 |
| 다른 변수에 할당 | 복사되어 전달<br />(pass by value) | 참조 값이 전달<br />(pass by reference) |

### 원시 타입

1. 원시 타입은 값은 계속 메모리에 존재하나 재할당시 새로운 값이 새로운 메모리에 올라가고 그것을 가르치는 것이므로 불변이다
2. 문자열 - 원시타입이나 유사 배열 객체로 취급

### 객체 타입

1. 다른 언어와 다르게 동적으로 추가가 가능 -> 사용하기는 편하나 비용이 많이든다.
   해당 문제를 해결하기 위해 동적탐색이 아닌 히든 클래스 라는 방식을 사용

## 12. 함수

1. 구성: 함수명, 매개변수, 인수, 몸체

2. 필요 이유?
   유지보수의 편의성, 코드의 신뢰성, 가독성

3. 정의 방식

   ```javascript
   function add(x,y){
   return x+y;
   }
   var add = function(x,y){
   return x+y;
   };
   var add = new Function('x','y','return x+y');
   var add = (x,y) => x+y;
   ```

4. 일급객체
   값의 성질을 갖는 객체

5. 호이스팅
   함수 표현식 - 변수 호이스팅이 발생
   함수 선언문 - 함수 호이스팅이 발생 => 함수 호출전에 함수를 선언할 필요가 없다. => 따라서 표현식이 권장(왜냐면 당연한 규칙을 무시해서)

6. Function - 권장하지 않는다.다양한 문제를 내포

7. 고려해야할 점

   1. 매개 변수와 인수의 개수를 확인 하지 않는다.
   2. 타입도 확인 하지 않는다.
   3. 단축 평가를 활용해 기본값을 할당할 수 도도 있다.
   4. ES6 부터는 매개변수 기본값을 사용해서 기본값을 초기화 할 수 있다.
   5. 프로퍼티를 사용하면 매개변수 순서를 안 지켜도 된다.

8. 즉시 실행 함수

   ```javascript
   (function(){
   var a = 3;
   var b = 5;
   return a*b;
   }());
   ```

   다시 호출 할 수 없다.

   즉시 실행 함수 내에 코드를 모아 두면 변수, 함수 이름 충돌 등을 방지 할 수 있다.

9. 재귀 함수 - 스택오버플로우 조심하자

10. 중첩합수

11. 콜백함수 - 함수형 프로그래밍, 비동기 처리에서 중요
    콜백함수 - 매개변수를 통해 전달된 함수
    고차함수 - 매개변수로 콜백함수를 받은 함수

12. 순수 - 외부 상태를 안 바꿈 -> 함수형 프로그래밍의 필수
    비순수 - 외부 상태를 변경